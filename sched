#!/bin/sh 

# WARNING: these are also defined in sched_from_cron!!!
X10dir="/usr2/foxharp/x10"
tmp_schedule="${X10dir}/tmp_schedule"
current_schedule="${X10dir}/current_schedule"
next_sched_prefix="${X10dir}/next_schedule"


writing_schedule=no
doxmas=maybe
dowater=no
doheat=maybe
vacation=no

#
# GLOBALS:
#   hour
#   minute
#

usage()
{
    cat <<EOF >&2
usage: $0 [-d]  keyword modifier
        use -d for debugging a new schedule without changing it
    Command keywords are:
        on,normal   - schedules everything to default values
        off,none    - eliminates any schedule, including any saved schedule
        rain,nowater - doesn't schedule any sprinklers
                  (in addition, turns water off immediately)
        water,norain - schedules water (default)
        heat    - schedules heat, no matter what month
        noheat  - no heat schedule, no matter what month
        vacation - vacation heat schedule, no water, "at home" lights.
        home    - regular default schedule (like 'on')
        xmas    - schedules xmas lights
        current - prints current schedule, without changing it
        cron    - prints default (cron) schedules, without changing them

    Command modifiers are:
        once      - The request is temporary. The default schedule
                    will be reapplied when cron is next scheduled
                    to run.  WARNING:  this is the default behavior.
        forever   - makes this the default schedule. This schedule
                    is reapplied whenever cron runs.    WARNING: old 
                    schedule is blown away, regardless of whether new 
                    schedule if valid!
        until DAY - make this the schedule until "DAY", at which time
                    the current schedule is restored.  "DAY" is the (possibly
                    abbreviated) name of a weekday.

    Defaults:   the schedule is modified just for now (i.e. cron will
            replace this with current schedule), as follows:
        heat is scheduled except in June, July, August, and September.
        water is scheduled.
        christmas lights are on in December and January.
        front porch light is always scheduled

    The vacation schedule keeps heat off, but turns it on for Sunday evenings,
    unless noheat is specified as well.
        

EOF
}

main()
{
    do_x10 reset a
    eventno=0

    set -- `date`
    month=$2

    echo Month is $month:

    if [ "$doxmas" = maybe ]
    then
	case $month in
	Dec|Jan)
	    ;;
	*)
	    echo Xmas ornaments only in december, and january
	    doxmas=no
	    ;;
	esac
    fi

    if [ "$dowater" = maybe ]
    then
	case $month in
	Nov|Dec|Jan|Feb|Mar|Apr)
	    echo No water scheduled from Nov through Apr
	    dowater=no
	    ;;
	esac
    elif [ "$dowater" = no ]
    then
	echo Turning all water off now, in addition to unscheduling
	do_x10 turn allwater off now

    fi

    if [ "$doheat" = maybe ]
    then
	case $month in
	Jun|Jul|Aug|Sep)
	    echo No heat schedule in june, july, august, or september
	    doheat=no
	    ;;
	esac
    fi


    # schedule the thermostat
    if [ "$vacation" = "yes" ]
    then
	do_vac_heat
	do_vac_lights
	module allwater off 1:00 everyday 

	[ "$dowater" != no ] && do_water # run the sprinklers
	[ "$doxmas" != no ] && do_xmas_orn # run the sprinklers
    else
	[ "$doheat" != no ]  && do_heat
	[ "$dowater" != no ] && do_water # run the sprinklers
	[ "$doxmas" != no ] && do_xmas_orn # run the sprinklers

    fi

    do_frontporch

    do_x10 dump events

    if [ "$next_schedule" ]
    then
	mv $current_schedule $next_schedule
    fi
    mv $tmp_schedule $current_schedule

}

do_water()
{
    #watertree Saturday Wednesday

    #watergrowing 8 9 10 11 12 13 14 15 16 17 18
    #watergrowing 8 10 12 14 16 18
    #watergrowing 9  13  17
    #watergrowing 7
    watergrown 6 Mon Wed Fri
    #waterback 7 Mon Thurs
    :
}


#
# Need to water new grass every day for short periods.
#
# args:
#   1... = hours
#
#   WARNING: length of time is hard coded below based on
#   the specific location of the sprinkler in quesion.
#
watergrowing()
{

    for hr in $*
    do
	resetcycle $hr
	waitfor 20
	sprinkle frontright   for 30 everyday
	sprinkle backleft     for 30 everyday
	waitfor 80
	sprinkle backright    for 30 everyday
	alloff
    done

}

#
# args:
#   1=hour to start
#   2... = days
#
watergrown()
{
    hr=$1
    shift

    for day in $*
    do
	resetcycle $hr
	sprinkle backright   for 30 $day
	sprinkle backleft     for 30 $day
	waitfor 20
	sprinkle frontright    for 30 $day
	alloff
    done
}

waterback()
{
    hr=$1
    shift

    for day in $*
    do
	minute=00
	resetcycle $hr
	sprinkle backlawn for	45 $day
	alloff
    done
}


watertree()
{

    whichhose=backleft
    when=7
    howlong=30	# 59 max

    for day in $*
    do
	schedule $whichhose normal $day $when:00 on
	schedule $whichhose normal $day $when:$howlong off
    done

    schedule allwater normal everyday $when:59 off

}

sprinkle()
{
    whichlawn=$1
    howlong=$3
    day=$4
    
    schedule $whichlawn normal $day $hour:$minute on
    waitfor $howlong
    schedule $whichlawn normal $day $hour:$minute off
}

alloff()
{
    schedule allwater normal everyday $hour:$minute off
}

waitfor()
{
    minute=`expr $minute + $1`
    if [ $minute -gt 59 ]
    then
	hour=`expr $hour + 1`
	minute=`expr $minute - 60`
    fi
    if [ $minute -lt 10 ]
    then
	minute=0$minute
    fi
    if [ $hour -gt 23 ]
    then
	hour=0
    fi
}

resetcycle()
{
    if [ "$hour" = "$1" -a "$minute" != 00 ]
    then
	echo Warning:  hour overlap at $hour >&2
    fi
    hour=$1
    minute=00
}

#   module batteries off 12:00 everyday 
#   do_batteries # schedule trickle charger on motorcycle batteries
#do_batteries()
#{
#   module batteries on  20:00 everyday 
#   module batteries off 20:15 everyday 
#   module batteries off 21:00 everyday 
#   module batteries off 22:00 everyday 
#   module batteries off 00:00 everyday 
#   module batteries off 02:00 everyday 
#   module batteries off 04:00 everyday 
#   module batteries off 08:00 everyday 
#   module batteries off 14:00 everyday 
#}

do_frontporch()
{
    module front_porch "dim 4" sunset+0:30 everyday
    module front_porch off 23:45 everyday
    module front_porch off 2:30 everyday
}

do_xmas_orn()
{
    schedule xmas_orn normal everyday sunset-0:30 on
    schedule xmas_orn normal everyday 22:55 off
}

do_vac_lights()
{
    schedule lamp1 security everyday sunset+0:45 on
    schedule lamp1 security everyday sunset+1:20 off
    schedule lamp1 security everyday 21:35 on
    schedule lamp1 security everyday 23:00 off

    schedule lamp2 security everyday sunset+0:54 on
    schedule lamp2 security everyday sunset+2:00 off
    schedule lamp2 security everyday 22:35 on
    schedule lamp2 security everyday 23:20 off
}


do_heat()
{
    module high_thermostat on 6:30 weekends
    module high_thermostat on 6:45 weekdays

    module high_thermostat on 18:05 everyday

    module high_thermostat off 8:00 weekdays
    module high_thermostat off 8:30 weekdays

    module high_thermostat off 22:40 sunday
    module high_thermostat off 22:40 monday
    module high_thermostat off 22:40 tuesday
    module high_thermostat off 22:40 wednesday
    module high_thermostat off 22:40 thursday

    module high_thermostat off 23:40 friday
    module high_thermostat off 23:40 saturday

    module high_thermostat off 23:59 everyday

}

do_vac_heat()
{
    # if we're doing heat at all, do it on sunday evenings
    if  [ "$doheat" = yes ]
    then
	module high_thermostat on 17:00 sunday
    fi
    module high_thermostat off 11:00 weekdays
    module high_thermostat off 22:30 weekdays
    module high_thermostat off 22:30 weekends
}

module()
{
    which="$1"
    setting="$2"
    time="$3"
    shift 3

    for day in $*
    do
	schedule $which normal $day $time $setting
    done
}

schedule()
{
    do_x10 schedule $* $eventno
    eventno=`expr $eventno + 1`
}

delete()
{
    do_x10 delete events $1-$2
}


#if debugging, the "x10" commands are just echo'd, and not executed
if [ "$1" = "-d" ]
then
    do_x10()
    {
	echo x10 $*
    }
    shift
else
    do_x10()
    {
	x10 $* || exit 1
	if [ "$writing_schedule" ]
	then
	    echo x10 $* >>$tmp_schedule
	fi
    }
fi


case $1 in
    rain*|nowater*)
	dowater=no
	;;
    norain*|water*)
	dowater=yes
	;;
    vacat*)
	vacation=yes
	;;
    noxmas*)
	doxmas=no
	;;
    xmas*)
	doxmas=yes
	;;
    noheat*)
	doheat=no
	;;
    heat*)
	doheat=yes
	;;
    special)
	vacation=yes
	dowater=yes
	;;
    on|home|normal)
	# run the schedule normally
	dowater=maybe
	doheat=maybe
	doxmas=maybe
	;;

    off)    # reset the cp290
	do_x10 reset a
	do_x10 dump events
	>$current_schedule
	exit
	;;

    show|current)   # just dump all scheduled events
	do_x10 dump events
	exit
	;;

    cron)
	# show schedule used by cron
	if [ -f $current_schedule ]
	then
	    echo The current schedule is:
	    cat $current_schedule
	    next_schedule=`ls $next_sched_prefix.* 2>/dev/null`
	    if [ "$next_schedule" ]
	    then
		echo "The next schedule ($next_schedule) is:"
		cat $next_schedule
	    else
		echo There is no "next" schedule for cron to pick up.
	    fi
	else
	    echo "No default schedule for cron"
	fi
	exit
	;;

    *)
	usage
	exit
	;;
    esac




if [ $# = 2 -o $# = 3 ]
then
    case $2 in
    forever)
	# save away schedule for cron to use
	rm -f $next_sched_prefix.*
	>$tmp_schedule
	writing_schedule=yes
	;;

    once)
	# this is the default behavior -- it overrides "until"!
	rm -f $next_sched_prefix.*
	;;

    until)
	# provide a day-of-week on which to end
	case $3 in
	    [Mm]on*)	dayofweek=Mon ;;
	    [Tt]ue*)	dayofweek=Tue ;;
	    [Ww]ed*)	dayofweek=Wed ;;
	    [Tt]hu*)	dayofweek=Thu ;;
	    [Ff]ri*)	dayofweek=Fri ;;
	    [Ss]at*)	dayofweek=Sat ;;
	    [Ss]un*)	dayofweek=Sun ;;
	    *)	    usage;  exit  ;;
	esac
	next_schedule=$next_sched_prefix.$dayofweek
	>$tmp_schedule
	writing_schedule=yes
	;;

    *)
	usage
	exit
	;;
    esac
fi



main 

